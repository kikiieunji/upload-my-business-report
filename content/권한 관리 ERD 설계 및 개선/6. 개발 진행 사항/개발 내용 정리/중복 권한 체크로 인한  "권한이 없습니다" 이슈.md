## 1. 배경 (Context)

기존 `GroupFunction` 기반 권한 시스템에서 사용자가 여러 `GroupFunction`에 속하거나 중복된 권한을 가질 때 권한 데이터의 중복(Duplicate) 문제가 발생했다. 이를 해결하고, 보다 유연한 DDD 기반의 Role 시스템으로 전환하는 과정에서 중복 제거 로직이 필수적

## 2. 문제점 (Problem)

### 2.1. 데이터 중복

- **현상**: 한 사용자가 여러 그룹(부서, 직책 등)에 속할 경우, 동일한 `GroupFunction` ID가 중복 조회됨
- **영향**:
  - 조회 쿼리 결과 뻥튀기 (Cartesian Product)
  - 비즈니스 로직(검증 등) 처리 시 성능 저하 및 예외 발생 가능성

### 2.2. 레거시 코드의 혼재

`ApprovalTemplateAggregateService` 등 주요 서비스에서 `GroupFunction`과 새로운 Role 엔티티가 공존하면서 로직이 복잡해짐

## 3. 해결 방안 (Solution)

### 3.1. Set 자료구조를 이용한 중복 제거

Java의 `Set` 인터페이스(구현체 `HashSet`)를 활용하여 ID 레벨에서 물리적인 중복을 원천 차단
```java
// ApprovalTemplateAggregateService.java
// 변경 전 (잠재적 중복 발생 가능)
// List<Long> ids = list.stream().map(Entity::getId).collect(Collectors.toList());

// 변경 후 (Set을 이용한 중복 제거)
Set<Long> templateRoleIds = atAuthorityList.stream()
    .filter(ata -> ata.getRole() != null)
    .map(ata -> ata.getRole().getId()) // Role ID 추출
    .collect(Collectors.toSet());      // Set으로 수집하여 자동 중복 제거
```

### 3.2. 유효 권한 필터링 로직 개선

중복이 제거된 ID 목록(`templateRoleIds`)을 기반으로 실제 유효한 사용자 부서/직급(UDP) 정보를 필터링
```java
List<Long> validUdpIdList;
if (!templateRoleIds.isEmpty()) {
    // 1. 중복 제거된 Role ID 리스트로 UdpRole 조회
    List<UdpRole> udpRoleList = udpRoleRepository.findbyRoleIdIn(new ArrayList<>(templateRoleIds));
    
    // 2. 유효한 UDP ID 추출
    validUdpIdList = udpRoleList.stream()
        .map(ur -> ur.getUdpId().getId())
        .collect(Collectors.toList());
} else {
    validUdpIdList = Collections.emptyList();
}
```

### 3.3. 상세 조회 시 필터링 적용

사용자 정보를 조립할 때 `validUdpIdList`에 포함된 정보만 남겨 권한 충돌을 방지
```java
if (!validUdpIdList.isEmpty()) {
    groupedUserDepartmentPosition = positions.stream()
        .filter(udp -> validUdpIdList.contains(udp.getId())) // 유효한 ID만 필터링
        .collect(Collectors.toList());
        
    if (groupedUserDepartmentPosition.isEmpty()) {
        throw new IllegalStateException("해당 권한(Role)을 가진 부서/직급 정보가 없습니다.");
    }
}
```

## 4. 리팩토링 차이점 (Refactoring Diff)

| 항목 | 기존 (Legacy) | 변경 후 (New System) |
|------|---------------|---------------------|
| 핵심 엔티티 | `GroupFunction` | `Role` |
| 중복 처리 | List 사용 (중복 존재) | `Set` 변환 후 List 재사용 (중복 제거) |
| 권한 검증 | 단순 ID 매칭 | 권한 ID 추출 → `UdpRole` 매핑 → 유효성 검증 |

## 5. 결론 (Conclusion)

- **데이터 무결성 확보**: `Set` 도입으로 중복 데이터 처리 로직을 간소화
- **확장성**: Role 기반으로 전환하면서 권한 부여 로직이 명확해짐
- **안정성**: `UserDepartmentPosition`과 매핑 시 정확한 필터링 수행으로 예외 상황 방지